# 响应式架构重构

### 本期议题

- 现代应用架构瓶颈
- 阻塞式应用架构重构
- 响应式应用架构重构

#### 现代应用架构瓶颈

- 网络
- 设计架构
- 应用性能

#### 阻塞式应用架构重构 

- 并发
- 并发
- 并发



## 分布式架构

分布式应用都是网络

### RPC（远程过程调用）

- dubbo
  - netty NIO + Async
- grpc

### MOM（消息中间件）

- RabbitMQ
- Mq类似

### DB（数据库）

- JDBC 连接



**关键字：网络**

- 网卡带宽
  - 1 GB
  - 100 MB
- 网络运用
  - < 1GB 

你没有用好。你带宽有 1GB 但是没有用到。



## 设计架构

### 业务架构

因系统而异

### 系统架构

- 非阻塞不一定是响应式
- 响应式一定是非阻塞



## 应用性能

- 阻塞式 + 不合理同步  （大多数）



#### 阻塞式

- 同步
- 等待结果返回

假如说：用户下单

​	用户服务 + 下单服务

​	 `100 ms`      +   `100 ms`   =    `> 200 ms`

```
1. 通过认证 token 查询 User 
2. User.id 执行下单服务
```



#### 两种模式

##### 依赖模式

C = A + B

A => B => C

##### 并行模式

C = A | B





例子：小明需要从数据库 A 和 数据库 B 拉去两份用户名单

原始模型

- 阻塞 =     Query A   ( 100ms )  + 	Query B ( 150ms ) > 250ms

重构模型

- 并行 =      Query A  ( 100ms )

​	               Query B ( 150ms )   > 150ms

```sequence
服务A->服务B: （请求）
服务B-->服务A: 100ms(响应)
服务A->服务C:  (请求)
服务C--> 服务A: 150ms （响应）
Note left of 服务A: 一共耗时 > 150ms

```







## Reactive Streams 框架



### Reactive Streams JVM

The purpose of Reactive Streams is to provide a standard for asynchronous stream processing with non-blocking backpressure. 

关键字：

- standard：技术标准 
- asynchronous stream processing：异步 Stream 处理
  - Java 8 Stream API
    - ` Stream.of(1,2,3,4,5).parallel().forEachOrdered(System.out::println);`
- non-blocking backpressure：非阻塞式被压
- 观察者模式扩展
- 异步/同步 混搭模式
  - 同步非阻塞
  - 异步非阻塞
- 非阻塞并非异步
  - NIO VS AIO



### 观察者模式 VS 迭代器模式



#### API 表述

- 观察者模式：Observable/Observer
- 迭代器模式：Iterator



#### 使用场景

- 观察者模式：推（Push-Based）模式
- 迭代器模式：拉（Pull-Based）模式



#### Java 8 Lambda 表达式

- `Function`
- `Consumer`
- `Supplier`



1. Publisher
   - 数据发布者
2. Subscriber
   - 数据消费者
3. Subscription
   - 数据订阅内容
4. Processor
   - Publisher +  Subscriber



#### 注意事项

- Reactive 是高端玩家的游戏
  - Java 8 Lambda
  - Java 并发
  - 观察者模式

优势

- 流式处理，面向数据
  - 数据 generate
  - 数据 merge
  - 数据 map
  - 数据 reduce
- 并行处理，无需关注线程池
  - 线程池无感
  - Future 无感
  - Callable/Runnable 无感
- 提高吞吐量
  - 并不意味处理事件变短
  - 执行时间变长
  - 处理的数量变多
    - 执行任务后台化



劣势

- 学习难度复杂
  - Java 8 Lambda
  - Java 并发
  - 观察者模式
- 不容易调试
- 容易出错
- API 组合太多





### Java 高并发



普遍性，高并发 = 高血压并发症

happens-before

happen-before

Lock-Free





JDBC Reactive 化



